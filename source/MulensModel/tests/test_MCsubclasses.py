import unittest

import numpy as np
import os

import MulensModel as mm

dir_2 = os.path.join(mm.DATA_PATH, 'unit_test_files')
SAMPLE_FILE = os.path.join(mm.DATA_PATH, 'unit_test_files', 'FSPL_test_1.dat')


# functions and classes for reading comparison files
def get_file_params(filename):
    """Read in the model parameters used to create the file"""
    with open(filename) as data_file:
        lines = data_file.readlines()
        ulens_params = lines[2].split()
    return (
        mm.ModelParameters(
            {'t_0': float(ulens_params[1]), 'u_0': float(ulens_params[2]),
             't_E': float(ulens_params[3]), 'rho': float(ulens_params[4])}),
        float(ulens_params[5]))


def get_variables():
    """return a few variables used by 4 test functions below"""
    if 'out' not in get_variables.__dict__:
        names = ['Time', 'b_0', 'b_1', 'Mag_FS', 'Mag_LD', 'Mag']
        data = np.genfromtxt(SAMPLE_FILE, names=names)
        (parameters, gamma) = get_file_params(SAMPLE_FILE)

        #point_lens = mm.PointLens(parameters=parameters)
        tau = (data['Time'] - parameters.t_0) / parameters.t_E
        u = np.sqrt(parameters.u_0**2 + tau**2)
        z = u / parameters.rho
        pspl_magnification = (u**2 + 2.) / (u * np.sqrt(u**2 + 4.))

        get_variables.out = (data, gamma, parameters, u, z, pspl_magnification)
    return get_variables.out

class FortranSFitFile(object):
    """
    Class to parse the comparison file generated by the Fortran version of sfit.
    """

    def __init__(self, filename):
        input_file = open(filename, 'r')
        attr = None
        for line in input_file.readlines():
            str_vec = line.strip().split()
            if str_vec[0] == '#':
                attr = str_vec[-1]
            else:
                if len(str_vec) == 1:
                    value = float(str_vec[0])
                else:
                    value = np.array([float(item) for item in str_vec])

                self.__setattr__(attr, value)

        input_file.close()

# Test PSPLMagnificationCurve
class Test_PSPLSMagnificationCurve(unittest.TestCase):

    def setUp(self):
        (data, _, parameters, _, _, pspl_magnification) = get_variables()
        self.pspl_parameters = {'t_0': parameters['t_0'], 'u_0': parameters['u_0'],
                                't_E': parameters['t_E']}
        self.data = data
        self.pspl_magnification = pspl_magnification


    def test_magnification(self):
        pspl_curve = mm.MagnificationCurve.PSPLMagnificationCurve(
            self.data['Time'], parameters=self.pspl_parameters)
        np.testing.assert_allclose(
            pspl_curve.get_magnification(), self.data['Mag'], rtol=0.0001)

    def test_check_parameters(self):
        # Good parameter combinations
        pspl_curve_1 = mm.MagnificationCurve.PSPLMagnificationCurve(
            self.data['Time'], parameters={'t_0': 0., 'u_0': 0.1, 't_E': 50.})
        pspl_curve_1 = mm.MagnificationCurve.PSPLMagnificationCurve(
            self.data['Time'], parameters={'t_0': 0., 'u_0': 0.1, 't_E': 50.,
                                           'pi_E_N': 0.0, 'pi_E_E': 0.01})
        pspl_curve_2 = mm.MagnificationCurve.PSPLMagnificationCurve(
            self.data['Time'], parameters={'t_0': 0., 'u_0': 0.1, 't_eff': 5.})
        pspl_curve_3 = mm.MagnificationCurve.PSPLMagnificationCurve(
            self.data['Time'], parameters={'t_0': 0., 't_eff': 5., 't_E': 50.})

        # Bad parameter combinations
        with self.assertRaises(KeyError):
            pspl_curve = mm.MagnificationCurve.PSPLMagnificationCurve(
                self.data['Time'],
                parameters={'t_0': 0., 'u_0': 0.1})

        with self.assertRaises(KeyError):
            pspl_curve = mm.MagnificationCurve.PSPLMagnificationCurve(
                self.data['Time'],
                parameters={'t_0': 0., 'u_0': 0.1, 't_E': 50, 'rho': 0.001})

        with self.assertRaises(KeyError):
            pspl_curve = mm.MagnificationCurve.PSPLMagnificationCurve(
                self.data['Time'],
                parameters={'t_0': 0., 'u_0': 0.0005, 't_E': 50, 'rho': 0.001})

    def test_get_d_A_d_params(self):
        raise NotImplementedError('No tests implemented for get_d_A_d_params.')


# Test FiniteSourceMagnificaitonCurves:
class Test_FiniteSourceUniformGould94MC(unittest.TestCase):

    def setUp(self):
        (data, _, parameters, _, z, _) = get_variables()
        self.data = data
        self.parameters = parameters

    def test_check_parameters(self):
        # Good parameter combinations
        fspl_curve = mm.MagnificationCurve.FiniteSourceUniformGould94MC(
            self.data['Time'],
            parameters={'t_0': 0., 'u_0': 0.0005, 't_E': 50, 'rho': 0.001})
        fspl_curve = mm.MagnificationCurve.FiniteSourceUniformGould94MC(
            self.data['Time'],
            parameters={'t_0': 0., 'u_0': 0.0005, 't_E': 50, 'rho': 0.001,
                        'pi_E_N': 0.0, 'pi_E_E': 0.01})
        fspl_curve = mm.MagnificationCurve.FiniteSourceUniformGould94MC(
            self.data['Time'],
            parameters={'t_0': 0., 'u_0': 0.0005, 't_E': 50, 't_star': 0.05})
        fspl_curve = mm.MagnificationCurve.FiniteSourceUniformGould94MC(
            self.data['Time'],
            parameters={'t_0': 0., 't_eff': 0.025, 't_E': 50, 't_star': 0.05})

        # Bad parameter combinations
        with self.assertRaises(KeyError):
            fspl_curve = mm.MagnificationCurve.FiniteSourceUniformGould94MC(
                self.data['Time'],
                parameters={'t_0': 0., 'u_0': 0.1, 't_E': 50})

        with self.assertRaises(KeyError):
            fspl_curve = mm.MagnificationCurve.FiniteSourceUniformGould94MC(
                self.data['Time'],
                parameters={'t_0': 0., 'u_0': 0.0005, 't_E': 50, 'rho': 0.001,
                            'alpha': 0.0, 'q': 0.001, 's': 1.0})

        with self.assertRaises(KeyError):
            fspl_curve = mm.MagnificationCurve.FiniteSourceUniformGould94MC(
                self.data['Time'],
                parameters={'t_0': 0., 'u_0': 0.0005, 't_E': 50, 'rho': 0.001},
                gamma=0.44)

        # Invalid Approximation
        with self.assertWarns(Warning):
            fspl_curve = mm.MagnificationCurve.FiniteSourceUniformGould94MC(
                self.data['Time'],
                parameters={'t_0': 0., 'u_0': 1.0, 't_E': 50, 'rho': 2.0})


    def test_B_0_function(self):
        """test private _B_0_function"""
        fspl_curve = mm.MagnificationCurve.FiniteSourceUniformGould94MC(
            self.data['Time'], parameters=self.parameters)
        np.testing.assert_almost_equal(
            fspl_curve.get_B_0(), self.data['b_0'], decimal=5)

    def test_get_magnification(self):
        """test PLFS"""
        fspl_curve = mm.MagnificationCurve.FiniteSourceUniformGould94MC(
            self.data['Time'], parameters=self.parameters)
        np.testing.assert_almost_equal(
            fspl_curve.get_magnification(), self.data['Mag_FS'], decimal=5)

    def test_get_d_A_d_params(self):
        raise NotImplementedError('No tests implemented for get_d_A_d_params.')


class Test_FiniteSourceLDYoo04MC(unittest.TestCase):

    def setUp(self):
        (data, gamma, parameters, _, z, _) = get_variables()
        self.data = data
        self.parameters = parameters
        self.gamma = gamma

    def test_check_parameters(self):
        # Good parameter combinations
        fspl_curve = mm.MagnificationCurve.FiniteSourceLDYoo04MC(
            self.data['Time'],
            parameters={'t_0': 0., 'u_0': 0.0005, 't_E': 50, 'rho': 0.001},
            gamma=0.44)
        fspl_curve = mm.MagnificationCurve.FiniteSourceLDYoo04MC(
            self.data['Time'],
            parameters={'t_0': 0., 'u_0': 0.0005, 't_E': 50, 'rho': 0.001,
                        'pi_E_N': 0.0, 'pi_E_E': 0.01}, gamma=0.44)
        fspl_curve = mm.MagnificationCurve.FiniteSourceLDYoo04MC(
            self.data['Time'],
            parameters={'t_0': 0., 'u_0': 0.1, 't_E': 50, 't_star': 0.05},
            gamma=0.44)
        fspl_curve = mm.MagnificationCurve.FiniteSourceLDYoo04MC(
            self.data['Time'],
            parameters={'t_0': 0., 't_eff': 5., 't_E': 50, 't_star': 0.05},
            gamma=0.44)

        # Bad parameter combinations
        with self.assertRaises(KeyError):
            fspl_curve = mm.MagnificationCurve.FiniteSourceLDYoo04MC(
                self.data['Time'],
                parameters={'t_0': 0., 'u_0': 0.1, 't_E': 50}, gamma=0.44)

        with self.assertRaises(KeyError):
            fspl_curve = mm.MagnificationCurve.FiniteSourceLDYoo04MC(
                self.data['Time'],
                parameters={'t_0': 0., 'u_0': 0.0005, 't_E': 50, 'rho': 0.001,
                            'alpha': 0.0, 'q': 0.001, 's': 1.0})

        with self.assertRaises(KeyError):
            fspl_curve = mm.MagnificationCurve.FiniteSourceLDYoo04MC(
                self.data['Time'],
                parameters={'t_0': 0., 'u_0': 0.0005, 't_E': 50, 'rho': 0.001})

        # Invalid Approximation
        with self.assertWarns(Warning):
            fspl_curve = mm.MagnificationCurve.FiniteSourceLDYoo04MC(
                self.data['Time'],
                parameters={'t_0': 0., 'u_0': 1.0, 't_E': 50, 'rho': 2.0}, gamma=0.44)

    def test_B_1_function(self):
        """test private _B_1_function"""
        fspl_curve = mm.MagnificationCurve.FiniteSourceLDYoo04MC(
            self.data['Time'], parameters=self.parameters, gamma=self.gamma)
        np.testing.assert_almost_equal(
            fspl_curve.get_B_1(), self.data['b_1'], decimal=4)

    def test_FiniteSourceLDYoo04MC_get_magnification(self):
        """test PLFS+LD"""
        fspl_curve = mm.MagnificationCurve.FiniteSourceLDYoo04MC(
            self.data['Time'], parameters=self.parameters, gamma=self.gamma)
        np.testing.assert_allclose(
            fspl_curve.get_magnification(), self.data['Mag_LD'], rtol=0.0001)

class Test_FiniteSourceLDYoo04MC_Derivs(unittest.TestCase):

    def setUp(self):
        # Read in sfit comparison file, split by dataset
        fspl_dir = 'fspl_derivs'
        self.sfit_derivs = np.genfromtxt(
            os.path.join(dir_2, fspl_dir, 'fort.61'), dtype=None,
            names=['nob', 'k', 't', 'dAdrho', 'mag', 'db0', 'db1'])

        # Create the model
        self.sfit_mat = FortranSFitFile(
            os.path.join(dir_2, fspl_dir, 'fort.51'))
        self.sfit_params = {
            't_0': self.sfit_mat.a[0] + 2450000., 'u_0': self.sfit_mat.a[1],
            't_E': self.sfit_mat.a[2], 'rho': self.sfit_mat.a[3]}
        t_star = self.sfit_params['rho'] * self.sfit_params['t_E']
        n_t_star = 9.
        gammas = {'I': 0.44, 'V': 0.72}

        self.filenames = ['FSPL_par_Obs_1_I.pho', 'FSPL_par_Obs_2_V.pho']
        self.datasets = []
        for filename in self.filenames:
            bandpass = filename.split('.')[0][-1]
            dataset = mm.MulensData(
                file_name=os.path.join(dir_2, fspl_dir, filename),
                phot_fmt='mag', bandpass=bandpass)
            self.datasets.append(dataset)

        self.sfit_indices = []
        self.indices = []
        self.mag_curves = []
        self.fits = []
        for i, dataset in enumerate(self.datasets):
            mag_curve = mm.FiniteSourceLDYoo94MC(
                dataset.time, parameters=self.sfit_params,
                gamma=gammas[dataset.bandpass])
            self.mag_curves.append(mag_curve)

            fit = mm.FitData(
                dataset=dataset, model=self.sfit_model,
                fix_source_flux=self.sfit_mat.a[9 + i * 3],
                fix_blend_flux=self.sfit_mat.a[9 + i * 3 + 1])
            fit.fit_fluxes()
            self.fits.append(fit)

            index = ((dataset.time >
                      self.sfit_model.parameters.t_0 - n_t_star * t_star) &
                     (dataset.time <
                      self.sfit_model.parameters.t_0 + n_t_star * t_star))
            self.indices.append(index)

            sfit_index = np.where(self.sfit_derivs['nob'] == i + 1)
            self.sfit_indices.append(sfit_index)

    def _db0_test(self, i):
        sfit_db0 = self.sfit_derivs[self.sfit_indices[i]]['db0']

        # sfit not accurate near 1:
        index = self.indices[i] & (np.abs(self.mag_curves[i].z - 1.) > 0.003)
        # transition between absolute and relative accuracy
        z_break = 1.3
        index_large = (self.mag_curves[i].z > z_break)
        index_small = (self.mag_curves[i].z <= z_break)
        for j, condition in enumerate([index_large, index_small]):
            if j == 0:
                kwargs = {'atol': 0.0005}
            else:
                kwargs = {'rtol': 0.01}

            index_i = condition
            if np.sum(index_i) > 0:
                db0 = self.mag_curves[i].get_B_0_prime()[index_i]
                np.testing.assert_allclose(db0, sfit_db0[index_i], **kwargs)

    def test_db0_0(self):
        self._db0_test(0)

    def test_db0_1(self):
        self._db0_test(1)

    def _db1_test(self, i):
        sfit_db1 = self.sfit_derivs[self.sfit_indices[i]]['db1']

        # sfit not accurate near 1:
        index = self.indices[i] & (np.abs(self.mag_curves[i].z - 1.) > 0.003)
        # transition between absolute and relative accuracy
        z_break = 1.3
        index_large = (self.mag_curves[i].z > z_break)
        index_small = (self.mag_curves[i].z <= z_break)
        for j, condition in enumerate([index_large, index_small]):
            if j == 0:
                kwargs = {'atol': 0.001}
            else:
                kwargs = {'rtol': 0.05}

            index_i = index & condition
            if np.sum(index_i) > 0:
                db1 = self.mag_curves[i].get_B_1_prime()[index_i]
                np.testing.assert_allclose(db1, sfit_db1[index_i], **kwargs)

    def test_db1_0(self):
        self._db1_test(0)

    def test_db1_1(self):
        self._db1_test(1)

    def _mags_test(self, i):
        mags = self.mag_curves[i].get_magnification()
        sfit_mags = self.sfit_derivs[self.sfit_indices[i]]['mag']
        np.testing.assert_allclose(mags, sfit_mags, rtol=0.005)

    def test_mags_0(self):
        self._mags_test(0)

    def test_mags_1(self):
        self._mags_test(1)

    def _dA_drho_test(self, i):
        # compare da_drho
        fs = self.fits[i].source_flux
        derivs = fs * self.mag_curves.get_d_A_d_rho()
        sfit_da_drho = self.sfit_derivs[self.sfit_indices[i]]['dAdrho']
        index = self.indices[i] & (np.abs(self.mag_curves[i].z - 1.) > 0.003)
        np.testing.assert_allclose(
            derivs[index], sfit_da_drho[index], rtol=0.015)

    def test_dAdrho_0(self):
        self._dA_drho_test(0)

    def test_dAdrho_1(self):
        self._dA_drho_test(1)